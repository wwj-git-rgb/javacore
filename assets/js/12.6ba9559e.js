(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{434:function(v,_,l){"use strict";l.r(_);var i=l(19),e=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h1",{attrs:{id:"java-编程规范"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#java-编程规范"}},[v._v("#")]),v._v(" Java 编程规范")]),v._v(" "),l("blockquote",[l("p",[v._v("编程规范就是 Java 开发的最佳实践。帮助开发人员少走弯路。")])]),v._v(" "),l("h2",{attrs:{id:"effective-java"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#effective-java"}},[v._v("#")]),v._v(" Effective Java")]),v._v(" "),l("ul",[l("li",[v._v("第 2 章 创建、销毁对象\n"),l("ul",[l("li",[v._v("第 1 条：考虑用静态工厂方法代替构造器")]),v._v(" "),l("li",[v._v("第 2 条：遇到多个构造器参数时要考虑用构建器")]),v._v(" "),l("li",[v._v("第 3 条：用私有构造器或者枚举类型强化 Singleton 属性")]),v._v(" "),l("li",[v._v("第 4 条：通过私有构造器强化不可实例化的能力")]),v._v(" "),l("li",[v._v("第 5 条：避免创建不必要的对象")]),v._v(" "),l("li",[v._v("第 6 条：消除过期的对象引用")]),v._v(" "),l("li",[v._v("第 7 条：避免使用终结方法")])])]),v._v(" "),l("li",[v._v("第 3 章 对于所有对象都通用的方法\n"),l("ul",[l("li",[v._v("第 8 条：覆盖 equals 时请遵守通用约定")]),v._v(" "),l("li",[v._v("第 9 条：覆盖 equals 时总要覆盖 hashCode")]),v._v(" "),l("li",[v._v("第 10 条：始终要覆盖 toString")]),v._v(" "),l("li",[v._v("第 11 条：谨慎地覆盖 clone")]),v._v(" "),l("li",[v._v("第 12 条：考虑实现 Comparable 接口")])])]),v._v(" "),l("li",[v._v("第 4 章 类和接口\n"),l("ul",[l("li",[v._v("第 13 条：使类和成员的可访问性最小化")]),v._v(" "),l("li",[v._v("第 14 条：在公有类中使用访问方法而非公有域")]),v._v(" "),l("li",[v._v("第 15 条：使可变性最小化")]),v._v(" "),l("li",[v._v("第 16 条：复合优先于继承")]),v._v(" "),l("li",[v._v("第 17 条：要么为继承而设计，并提供文档说明，要么就禁止继承")]),v._v(" "),l("li",[v._v("第 18 条：接口优于抽象类")]),v._v(" "),l("li",[v._v("第 19 条：接口只用于定义类型")]),v._v(" "),l("li",[v._v("第 20 条：类层次优于标签类")]),v._v(" "),l("li",[v._v("第 21 条：用函数对象表示策略")]),v._v(" "),l("li",[v._v("第 22 条：优先考虑静态成员类")])])]),v._v(" "),l("li",[v._v("第 5 章 泛型\n"),l("ul",[l("li",[v._v("第 23 条：请不要在新代码中使用原生态类型")]),v._v(" "),l("li",[v._v("第 24 条：消除非受检警告")]),v._v(" "),l("li",[v._v("第 25 条：列表优先于数组")]),v._v(" "),l("li",[v._v("第 26 条：优先考虑泛型")]),v._v(" "),l("li",[v._v("第 27 条：优先考虑泛型方法")]),v._v(" "),l("li",[v._v("第 28 条：利用有限制通配符来提升 API 的灵活性")]),v._v(" "),l("li",[v._v("第 29 条：优先考虑类型安全的异构容器")])])]),v._v(" "),l("li",[v._v("第 6 章 枚举和注解\n"),l("ul",[l("li",[v._v("第 30 条：用 enum 代替 int 常量")]),v._v(" "),l("li",[v._v("第 31 条：用实例域代替序数")]),v._v(" "),l("li",[v._v("第 32 条：用 EnumSet 代替位域")]),v._v(" "),l("li",[v._v("第 33 条：用 EnumMap 代替序数索引")]),v._v(" "),l("li",[v._v("第 34 条：用接口模拟可伸缩的枚举")]),v._v(" "),l("li",[v._v("第 35 条：注解优先于命名模式")]),v._v(" "),l("li",[v._v("第 36 条：坚持使用 Override 注解")]),v._v(" "),l("li",[v._v("第 37 条：用标记接口定义类型")])])]),v._v(" "),l("li",[v._v("第 7 章 方法\n"),l("ul",[l("li",[v._v("第 38 条：检查参数的有效性")]),v._v(" "),l("li",[v._v("第 39 条：必要时进行保护性拷贝")]),v._v(" "),l("li",[v._v("第 40 条：谨慎设计方法签名")]),v._v(" "),l("li",[v._v("第 41 条：慎用重载")]),v._v(" "),l("li",[v._v("第 42 条：慎用可变参数")]),v._v(" "),l("li",[v._v("第 43 条：返回零长度的数组或者集合，而不是：null")]),v._v(" "),l("li",[v._v("第 44 条：为所有导出的 API 元素编写文档注释")])])]),v._v(" "),l("li",[v._v("第 8 章 通用程序设计\n"),l("ul",[l("li",[v._v("第 45 条：将局部变量的作用域最小化")]),v._v(" "),l("li",[v._v("第 46 条：for-each 循环优先于传统的 for 循环")]),v._v(" "),l("li",[v._v("第 47 条：了解和使用类库")]),v._v(" "),l("li",[v._v("第 48 条：如果需要精确的答案，请避免使用 float 和 double")]),v._v(" "),l("li",[v._v("第 49 条：基本类型优先于装箱基本类型")]),v._v(" "),l("li",[v._v("第 50 条：如果其他类型更适合，则尽量避免使用字符串")]),v._v(" "),l("li",[v._v("第 51 条：当心字符串连接的性能")]),v._v(" "),l("li",[v._v("第 52 条：通过接口引用对象")]),v._v(" "),l("li",[v._v("第 53 条：接口优先于反射机制")]),v._v(" "),l("li",[v._v("第 54 条：谨慎地使用本地方法")]),v._v(" "),l("li",[v._v("第 55 条：谨慎地进行优化")]),v._v(" "),l("li",[v._v("第 56 条：遵守普遍接受的命名惯例")])])]),v._v(" "),l("li",[v._v("第 9 章 异常\n"),l("ul",[l("li",[v._v("第 57 条：只针对异常的情况才使用异常")]),v._v(" "),l("li",[v._v("第 58 条：对可恢复的情况使用受检异常，对编程错误使用运行时异常")]),v._v(" "),l("li",[v._v("第 59 条：避免不必要地使用受检的异常")]),v._v(" "),l("li",[v._v("第 60 条：优先使用标准的异常")]),v._v(" "),l("li",[v._v("第 61 条：抛出与抽象相对应的异常")]),v._v(" "),l("li",[v._v("第 62 条：每个方法抛出的异常都要有文档")]),v._v(" "),l("li",[v._v("第 63 条：在细节消息中包含能捕获失败的信息")]),v._v(" "),l("li",[v._v("第 64 条：努力使失败保持原子性")]),v._v(" "),l("li",[v._v("第 65 条：不要忽略异常")])])]),v._v(" "),l("li",[v._v("第 10 章 并发\n"),l("ul",[l("li",[v._v("第 66 条：同步访问共享的可变数据")]),v._v(" "),l("li",[v._v("第 67 条：避免过度同步")]),v._v(" "),l("li",[v._v("第 68 条：executor 和 task 优先干线程")]),v._v(" "),l("li",[v._v("第 69 条：并发工具优先于 wait 和 notify")]),v._v(" "),l("li",[v._v("第 70 条：线程安全性的文档化")]),v._v(" "),l("li",[v._v("第 71 条：慎用延迟初始化")]),v._v(" "),l("li",[v._v("第 72 条：不要依赖于线程调度器")]),v._v(" "),l("li",[v._v("第 73 条：避免使用线程组")])])]),v._v(" "),l("li",[v._v("第 11 章 序列化\n"),l("ul",[l("li",[v._v("第 74 条：谨慎地实现 Serializable 接口")]),v._v(" "),l("li",[v._v("第 75 条：考虑使用自定义的序列化形式")]),v._v(" "),l("li",[v._v("第 76 条：保护性地编写 readObject 方法")]),v._v(" "),l("li",[v._v("第 77 条：对于实例控制，枚举类型优先于 readResolve")]),v._v(" "),l("li",[v._v("第 78 条：考虑用序列化代理代替序列化实例")])])])]),v._v(" "),l("h2",{attrs:{id:"资源"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#资源"}},[v._v("#")]),v._v(" 资源")]),v._v(" "),l("ul",[l("li",[l("a",{attrs:{href:"https://book.douban.com/subject/3360807/",target:"_blank",rel:"noopener noreferrer"}},[v._v("Effective Java"),l("OutboundLink")],1)]),v._v(" "),l("li",[l("a",{attrs:{href:"https://github.com/alibaba/p3c/blob/master/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E8%AF%A6%E5%B0%BD%E7%89%88%EF%BC%89.pdf",target:"_blank",rel:"noopener noreferrer"}},[v._v("阿里巴巴 Java 开发手册"),l("OutboundLink")],1)]),v._v(" "),l("li",[l("a",{attrs:{href:"https://google.github.io/styleguide/javaguide.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("Google Java 编程指南"),l("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=e.exports}}]);